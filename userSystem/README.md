# Go项目合集系列一：注册登录模块设计

关键要点：

1. 数据库不能保存明文密码
1. 传输过程不能明文传输
1. 不能信任前端传输的敏感数据
1. 使用https



对于常见的设计方法，安全性从低到高排列：

- 前端对密码进行MD5加密后传给后台。缺点：MD5可以彩虹表碰撞，并且可以直接截取用户名和MD5加密后的密文密码作为参数直接调用登录接口。
- RSA加密，前端保留RSA公钥文件，服务器后端保留RSA私钥文件，登录时，前端使用公钥对密码进行加密，后端接收到后使用私钥解密。缺点：若截取到用户名和公钥加密后的密文密码直接调用登录接口，也可以登录成功。
- 用户每次登录时，由服务端生成一个随机RSA密钥对，将公钥返回给前端，私钥保存到服务器，并设置该密钥对的有效期。



综上考虑，得出本系统的设计如下：
#### 注册接口设计
&ensp;&ensp; 密码传输过程不能明文，但是又不能信任前端传输的敏感数据，如要检验密码的强度，单纯靠前端检验是不安全的，所以要保证后端可以拿到明文密码进行校验。于是可以如下设计：以邮箱注册举例，首先需要一个发送邮箱验证码的接口，前端先调用发送邮箱验证码接口，接口返回给前端随机生成的RSA密钥对的公钥，注册时，前端使用得到的RSA公钥将密码加密后调用注册接口，后端使用私钥解密后得到明文密码，进行对密码的强度检验，逻辑处理完后，随机生成一个salt值，将明文密码与salt一起MD5加密后存放在数据库中。取随机salt值是为了避免使用彩虹表碰撞解密，保证即使不同用户密码相同，但是加上随机salt后生成的密文也不同。
#### 登录接口设计
&ensp;&ensp; 用户每次登录前，前端页面可以设计为在输入完账号后，首先调用findUser接口，检查用户是否存在，若不存在，提示用户需要先注册，若存在，则由服务端生成一个随机RSA密钥对，将公钥返回给前端，私钥保存到服务器，并设置该密钥对的有效期。用户在登录时，调用登录接口，前端对用户的明文密码进行公钥加密后传给后端，后端用私钥对密码进行解密，然后取出数据库对应的salt值，md5(密码,salt)后与数据库保存的密码进行匹配(因为数据库保存的密码不是明文，参照注册接口设计)，登录成功之后，服务器立即清除这个密钥对。因此即使攻击者拦截到了加密后的密文(没有私钥也无法解密)，并用这个加密后的密文再次伪造登录，也无法成功，因为服务器已经清除了密钥对。
<br>
&ensp;&ensp; 登录成功后，如何保存用户登录状态，以及对接口进行鉴权设计，这里使用JWT作为本系统的身份检验机制。具体步骤是：登录成功后，后端生成一个带有过期时间的jwt-token返回给前端，前端之后请求接口都要带上这个jwt-token。

以下是前后端的交互过程用例图：

- 注册
<br>
![](https://user-gold-cdn.xitu.io/2020/7/2/1730e37b72526fbb?w=809&h=539&f=svg&s=10638)

- 登录
<br>
![](https://user-gold-cdn.xitu.io/2020/7/2/1730e37b726e994b?w=770&h=698&f=svg&s=13694)

> jwt的使用问题：注销登录、忘记密码操作时需要服务端拦截过期token，可以引入预黑名单机制。把要注销的用户 id 和当前时间（TIME） 组成 key-value 加入到Redis预黑名单，下次请求时，若其 id 和黑名单中的对应，并且签发时间在 TIME 之前，则将其拦截。这样查找范围就可以缩小到未过期但又要注销的用户。



附上源码地址：[https://github.com/togettoyou/awesomeGoProject/tree/master/userSystem](https://github.com/togettoyou/awesomeGoProject/tree/master/userSystem)
